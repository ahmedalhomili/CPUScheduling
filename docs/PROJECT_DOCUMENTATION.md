# 📚 توثيق مشروع محاكي جدولة المعالج
# CPU Scheduling Algorithms Simulator - Documentation

---

## 📋 فهرس المحتويات

1. [نظرة عامة على المشروع](#1-نظرة-عامة-على-المشروع)
2. [هيكل المشروع](#2-هيكل-المشروع)
3. [هياكل البيانات](#3-هياكل-البيانات)
4. [خوارزميات الجدولة](#4-خوارزميات-الجدولة)
5. [مقارنة الخوارزميات](#5-مقارنة-الخوارزميات)
6. [المخططات البيانية](#6-المخططات-البيانية)
7. [دليل الاستخدام](#7-دليل-الاستخدام)
8. [المراجع](#8-المراجع)

---

## 1. نظرة عامة على المشروع

### 1.1 وصف المشروع

مشروع محاكي جدولة المعالج هو تطبيق تعليمي مبني بلغة C++ بأسلوب البرمجة الإجرائية (Procedural Programming) بدون استخدام OOP. يهدف المشروع إلى:

- **شرح عملي** لكيفية عمل خوارزميات جدولة المعالج
- **بناء هياكل البيانات من الصفر** بدون استخدام مكتبات STL الجاهزة
- **مقارنة أداء** الخوارزميات المختلفة
- **واجهة رسومية** باستخدام Python/Flet

### 1.2 المتطلبات التقنية

| المتطلب | الإصدار |
|---------|---------|
| C++ Standard | C++17 |
| CMake | 3.20+ |
| Python (للواجهة) | 3.8+ |
| Flet | 0.28+ |

### 1.3 المفاهيم الأساسية

```
┌─────────────────────────────────────────────────────────────┐
│                    CPU Scheduling                            │
├─────────────────────────────────────────────────────────────┤
│  العملية (Process): برنامج قيد التنفيذ                      │
│  وقت الوصول (Arrival Time): متى وصلت العملية                │
│  وقت التنفيذ (Burst Time): المدة اللازمة للتنفيذ            │
│  الأولوية (Priority): أهمية العملية                         │
│  وقت الانتظار (Waiting Time): مدة الانتظار في الطابور       │
│  وقت الدوران (Turnaround Time): من الوصول حتى الاكتمال      │
└─────────────────────────────────────────────────────────────┘
```

### 1.4 المعادلات الأساسية

```
Turnaround Time = Completion Time - Arrival Time
Waiting Time = Turnaround Time - Burst Time
Response Time = First Execution Time - Arrival Time
CPU Utilization = (Total Burst Time / Total Time) × 100%
```

---

## 2. هيكل المشروع

### 2.1 شجرة الملفات

```
CPUScheduling/
│
├── 📄 main.cpp                    # نقطة الدخول الرئيسية
├── 📄 CMakeLists.txt              # ملف بناء CMake
├── 📄 README.md                   # وصف المشروع
├── 📄 .gitignore                  # ملفات Git المتجاهلة
│
├── 📁 src/                        # الكود المصدري
│   ├── 📄 types.cpp               # تعريف الأنواع والهياكل
│   ├── 📄 api.cpp                 # واجهة برمجية للتكامل
│   ├── 📄 io_handler.cpp          # التعامل مع الملفات والطباعة
│   │
│   ├── 📁 data_structures/        # هياكل البيانات
│   │   ├── 📄 queue.cpp           # الطابور (Queue)
│   │   ├── 📄 priority_queue.cpp  # طابور الأولوية (Min-Heap)
│   │   ├── 📄 linked_list.cpp     # القائمة المترابطة
│   │   └── 📄 stack.cpp           # المكدس (Stack)
│   │
│   └── 📁 algorithms/             # خوارزميات الجدولة
│       ├── 📄 algorithms.cpp      # ملف التجميع
│       ├── 📄 fcfs.cpp            # First Come First Serve
│       ├── 📄 sjf.cpp             # Shortest Job First
│       ├── 📄 priority.cpp        # Priority Scheduling
│       └── 📄 round_robin.cpp     # Round Robin
│
├── 📁 gui/                        # الواجهة الرسومية
│   ├── 📄 scheduler_gui.py        # واجهة Flet
│   └── 📄 scheduler_api.py        # API للتواصل
│
├── 📁 data/                       # ملفات البيانات
│   ├── 📄 sample_input.txt
│   └── 📄 test_*.txt
│
├── 📁 docs/                       # التوثيق
│   └── 📄 PROJECT_DOCUMENTATION.md
│
└── 📁 build/                      # ملفات البناء
```

### 2.2 سلسلة التضمين (Include Chain)

```
main.cpp
    └── src/api.cpp
            └── src/io_handler.cpp
                    └── src/algorithms/algorithms.cpp
                            ├── fcfs.cpp ──────────► queue.cpp ──────────► types.cpp
                            ├── sjf.cpp ───────────► priority_queue.cpp ─► types.cpp
                            ├── priority.cpp ──────► linked_list.cpp ────► types.cpp
                            └── round_robin.cpp ───► stack.cpp ──────────► types.cpp
```

---

## 3. هياكل البيانات

### 3.1 الطابور (Queue) - FIFO

#### المفهوم
الطابور يعمل بمبدأ **FIFO** (First In First Out) - أول عنصر يدخل هو أول عنصر يخرج.

#### البنية
```cpp
struct QueueNode {
    Process data;      // البيانات
    QueueNode* next;   // مؤشر للعقدة التالية
};

struct Queue {
    QueueNode* front;  // مقدمة الطابور
    QueueNode* rear;   // مؤخرة الطابور
    int size;          // عدد العناصر
};
```

#### العمليات
| العملية | التعقيد | الوصف |
|---------|---------|-------|
| `queue_create()` | O(1) | إنشاء طابور جديد |
| `queue_enqueue()` | O(1) | إضافة عنصر في النهاية |
| `queue_dequeue()` | O(1) | إزالة عنصر من البداية |
| `queue_peek()` | O(1) | عرض أول عنصر بدون إزالة |
| `queue_is_empty()` | O(1) | التحقق من الفراغ |
| `queue_destroy()` | O(n) | تحرير الذاكرة |

#### رسم توضيحي
```
Enqueue (إضافة)                      Dequeue (إزالة)
    ↓                                     ↓
┌───┬───┬───┬───┬───┐              ┌───┬───┬───┬───┬───┐
│ A │ B │ C │ D │ E │    ═══►      │ B │ C │ D │ E │   │
└───┴───┴───┴───┴───┘              └───┴───┴───┴───┴───┘
  ↑                                   ↑               ↑
Front                              Front            Rear
```

#### الاستخدام في المشروع
يُستخدم في خوارزمية **FCFS** و **Round Robin** لإدارة قائمة العمليات الجاهزة.

---

### 3.2 طابور الأولوية (Priority Queue) - Min-Heap

#### المفهوم
طابور الأولوية مبني على **Min-Heap** - العنصر ذو القيمة الأصغر (الأولوية الأعلى) يخرج أولاً.

#### البنية
```cpp
typedef bool (*CompareFunction)(const Process&, const Process&);

struct PriorityQueue {
    Process* heap;         // مصفوفة الـ Heap
    int capacity;          // السعة القصوى
    int size;              // الحجم الحالي
    CompareFunction compare; // دالة المقارنة
};
```

#### خاصية Min-Heap
```
للعقدة في الفهرس i:
  - الأب (Parent): (i - 1) / 2
  - الابن الأيسر (Left): 2*i + 1
  - الابن الأيمن (Right): 2*i + 2
  
شرط Min-Heap: heap[parent] ≤ heap[children]
```

#### العمليات
| العملية | التعقيد | الوصف |
|---------|---------|-------|
| `pq_create()` | O(1) | إنشاء طابور أولوية |
| `pq_insert()` | O(log n) | إدخال عنصر |
| `pq_extract_min()` | O(log n) | استخراج الأصغر |
| `heapify_up()` | O(log n) | إعادة ترتيب للأعلى |
| `heapify_down()` | O(log n) | إعادة ترتيب للأسفل |

#### رسم توضيحي - Min-Heap
```
        ┌───┐
        │ 1 │         المستوى 0
        └─┬─┘
      ┌───┴───┐
    ┌─┴─┐   ┌─┴─┐
    │ 3 │   │ 2 │     المستوى 1
    └─┬─┘   └─┬─┘
   ┌──┴──┐ ┌──┴──┐
 ┌─┴─┐┌─┴─┐┌─┴─┐┌─┴─┐
 │ 5 ││ 4 ││ 7 ││ 6 │ المستوى 2
 └───┘└───┘└───┘└───┘

 تمثيل المصفوفة: [1, 3, 2, 5, 4, 7, 6]
```

#### دوال المقارنة
```cpp
// مقارنة حسب Burst Time (للـ SJF)
bool compare_by_burst_time(const Process& a, const Process& b);

// مقارنة حسب Remaining Time (للـ SRTF)
bool compare_by_remaining_time(const Process& a, const Process& b);

// مقارنة حسب Priority
bool compare_by_priority(const Process& a, const Process& b);
```

---

### 3.3 القائمة المترابطة المزدوجة (Doubly Linked List)

#### المفهوم
قائمة مترابطة **ثنائية الاتجاه** - كل عقدة تحتوي على مؤشر للعقدة السابقة والتالية.

#### البنية
```cpp
struct ListNode {
    Process data;      // البيانات
    ListNode* next;    // العقدة التالية
    ListNode* prev;    // العقدة السابقة
};

struct LinkedList {
    ListNode* head;    // رأس القائمة
    ListNode* tail;    // ذيل القائمة
    int size;          // عدد العناصر
};
```

#### العمليات
| العملية | التعقيد | الوصف |
|---------|---------|-------|
| `list_insert_front()` | O(1) | إدراج في البداية |
| `list_insert_back()` | O(1) | إدراج في النهاية |
| `list_remove_front()` | O(1) | حذف من البداية |
| `list_remove_back()` | O(1) | حذف من النهاية |
| `list_find_min_priority()` | O(n) | البحث عن أقل أولوية |

#### رسم توضيحي
```
NULL ◄─── ┌───┐ ◄───► ┌───┐ ◄───► ┌───┐ ◄───► ┌───┐ ───► NULL
          │ A │       │ B │       │ C │       │ D │
          └───┘       └───┘       └───┘       └───┘
            ↑                                   ↑
          Head                                Tail
```

#### الاستخدام في المشروع
تُستخدم في خوارزمية **Priority Scheduling** للبحث عن العملية ذات الأولوية الأعلى.

---

### 3.4 المكدس (Stack) - LIFO

#### المفهوم
المكدس يعمل بمبدأ **LIFO** (Last In First Out) - آخر عنصر يدخل هو أول عنصر يخرج.

#### البنية
```cpp
struct StackNode {
    Process data;      // البيانات
    StackNode* next;   // العقدة التالية
};

struct Stack {
    StackNode* top;    // قمة المكدس
    int size;          // عدد العناصر
};
```

#### العمليات
| العملية | التعقيد | الوصف |
|---------|---------|-------|
| `stack_push()` | O(1) | إضافة عنصر للقمة |
| `stack_pop()` | O(1) | إزالة عنصر من القمة |
| `stack_peek()` | O(1) | عرض القمة بدون إزالة |
| `stack_is_empty()` | O(1) | التحقق من الفراغ |

#### رسم توضيحي
```
    Push (E)                Pop
       ↓                      ↑
    ┌─────┐               ┌─────┐
    │  E  │ ← Top         │     │
    ├─────┤               ├─────┤
    │  D  │               │  D  │ ← Top
    ├─────┤               ├─────┤
    │  C  │               │  C  │
    ├─────┤               ├─────┤
    │  B  │               │  B  │
    ├─────┤               ├─────┤
    │  A  │               │  A  │
    └─────┘               └─────┘
```

#### الاستخدام في المشروع
يُستخدم لتتبع **سجلات التنفيذ** (Execution Records) في Round Robin.

---

## 4. خوارزميات الجدولة

### 4.1 FCFS - First Come First Serve

#### المفهوم
أبسط خوارزميات الجدولة - **أول عملية تصل هي أول عملية تُنفذ**.

#### الخصائص
- ✅ **غير استباقية** (Non-Preemptive)
- ✅ بسيطة التنفيذ
- ❌ قد تسبب **Convoy Effect**
- ❌ وقت انتظار طويل للعمليات القصيرة

#### الخوارزمية
```
1. رتب العمليات حسب وقت الوصول (Arrival Time)
2. لكل عملية بالترتيب:
   a. إذا لم تصل بعد → انتظر
   b. نفذ العملية بالكامل
   c. احسب Completion, Waiting, Turnaround
3. انتهى
```

#### Flowchart
```
┌─────────────────┐
│     البداية     │
└────────┬────────┘
         ▼
┌─────────────────┐
│ ترتيب حسب      │
│ Arrival Time    │
└────────┬────────┘
         ▼
┌─────────────────┐
│ i = 0           │
│ current_time = 0│
└────────┬────────┘
         ▼
    ┌────┴────┐
    │ i < n ? │
    └────┬────┘
     نعم │         لا
         ▼          ▼
┌─────────────┐  ┌──────┐
│ العملية[i]  │  │النهاية│
│ وصلت؟      │  └──────┘
└──────┬──────┘
   نعم │    لا
       ▼     ▼
┌───────────┐ ┌─────────────┐
│ نفذ       │ │ انتظر حتى  │
│ العملية   │ │ تصل        │
└─────┬─────┘ └──────┬──────┘
      │              │
      └──────┬───────┘
             ▼
    ┌─────────────────┐
    │ احسب:          │
    │ Completion      │
    │ Waiting         │
    │ Turnaround      │
    └────────┬────────┘
             ▼
    ┌─────────────────┐
    │ i++             │
    └────────┬────────┘
             │
             └──────► (العودة للتحقق)
```

#### مثال
```
العمليات:
┌─────┬─────────┬───────┐
│ PID │ Arrival │ Burst │
├─────┼─────────┼───────┤
│ P1  │    0    │   5   │
│ P2  │    1    │   3   │
│ P3  │    2    │   8   │
└─────┴─────────┴───────┘

Gantt Chart:
┌─────────────┬───────────┬─────────────────────┐
│     P1      │    P2     │         P3          │
│   (0-5)     │  (5-8)    │      (8-16)         │
└─────────────┴───────────┴─────────────────────┘
0             5           8                     16

النتائج:
┌─────┬────────────┬─────────┬────────────┐
│ PID │ Completion │ Waiting │ Turnaround │
├─────┼────────────┼─────────┼────────────┤
│ P1  │     5      │    0    │     5      │
│ P2  │     8      │    4    │     7      │
│ P3  │    16      │    6    │    14      │
└─────┴────────────┴─────────┴────────────┘

Average Waiting Time = (0 + 4 + 6) / 3 = 3.33
Average Turnaround Time = (5 + 7 + 14) / 3 = 8.67
```

---

### 4.2 SJF - Shortest Job First

#### 4.2.1 SJF Non-Preemptive

##### المفهوم
تنفيذ **أقصر عملية أولاً** من بين العمليات الجاهزة.

##### الخصائص
- ✅ **غير استباقية**
- ✅ تقلل Average Waiting Time
- ✅ مثالية نظرياً
- ❌ قد تسبب **Starvation** للعمليات الطويلة
- ❌ تحتاج معرفة Burst Time مسبقاً

##### الخوارزمية
```
1. current_time = 0, completed = 0
2. طالما completed < n:
   a. ابحث عن أقصر عملية وصلت ولم تكتمل
   b. إذا لم توجد → current_time++
   c. نفذ العملية بالكامل
   d. احسب الأوقات
   e. completed++
3. انتهى
```

##### مثال
```
العمليات:
┌─────┬─────────┬───────┐
│ PID │ Arrival │ Burst │
├─────┼─────────┼───────┤
│ P1  │    0    │   7   │
│ P2  │    2    │   4   │
│ P3  │    4    │   1   │
│ P4  │    5    │   4   │
└─────┴─────────┴───────┘

Gantt Chart:
┌─────────────────────┬───┬───────────┬───────────┐
│         P1          │P3 │    P2     │    P4     │
│       (0-7)         │7-8│   (8-12)  │  (12-16)  │
└─────────────────────┴───┴───────────┴───────────┘
0                     7   8           12          16

ملاحظة: P3 (burst=1) نُفذت قبل P2 (burst=4) رغم وصول P2 أولاً
```

#### 4.2.2 SJF Preemptive (SRTF)

##### المفهوم
**Shortest Remaining Time First** - في كل وحدة زمنية، نختار العملية ذات أقصر وقت متبقي.

##### الخصائص
- ✅ **استباقية** (Preemptive)
- ✅ أفضل Average Waiting Time ممكن
- ❌ Context Switching عالي
- ❌ Starvation أكبر

##### الخوارزمية
```
1. current_time = 0, completed = 0
2. طالما completed < n:
   a. ابحث عن العملية ذات أقصر remaining_time
   b. إذا وصلت عملية جديدة أقصر → preempt
   c. نفذ وحدة زمنية واحدة
   d. remaining_time--
   e. إذا remaining_time == 0 → completed++
3. انتهى
```

##### مثال
```
العمليات:
┌─────┬─────────┬───────┐
│ PID │ Arrival │ Burst │
├─────┼─────────┼───────┤
│ P1  │    0    │   8   │
│ P2  │    1    │   4   │
│ P3  │    2    │   2   │
└─────┴─────────┴───────┘

Gantt Chart (SRTF):
┌───┬─────┬───────────┬─────────────────────┐
│P1 │ P2  │    P3     │    P2   │    P1     │
│0-1│ 1-2 │   2-4     │   4-7   │   7-14    │
└───┴─────┴───────────┴─────────┴───────────┘
0   1     2           4         7           14

في الوقت 1: وصل P2 (remaining=4) أقصر من P1 (remaining=7) → Preempt
في الوقت 2: وصل P3 (remaining=2) أقصر من P2 (remaining=4) → Preempt
```

---

### 4.3 Priority Scheduling

#### 4.3.1 Priority Non-Preemptive

##### المفهوم
تنفيذ العملية ذات **الأولوية الأعلى** (القيمة الأصغر = أولوية أعلى).

##### الخصائص
- ✅ مرونة في تحديد الأهمية
- ❌ **Starvation** للأولويات المنخفضة
- 💡 الحل: **Aging** (زيادة الأولوية مع الوقت)

##### الخوارزمية
```
1. current_time = 0, completed = 0
2. طالما completed < n:
   a. ابحث عن العملية ذات أعلى أولوية (أصغر قيمة)
   b. نفذها بالكامل
   c. احسب الأوقات
3. انتهى
```

#### 4.3.2 Priority Preemptive

##### المفهوم
إذا وصلت عملية جديدة بأولوية أعلى → **توقف العملية الحالية**.

##### مثال
```
العمليات:
┌─────┬─────────┬───────┬──────────┐
│ PID │ Arrival │ Burst │ Priority │
├─────┼─────────┼───────┼──────────┤
│ P1  │    0    │   5   │    3     │
│ P2  │    1    │   3   │    1     │ ← أعلى أولوية
│ P3  │    2    │   4   │    2     │
└─────┴─────────┴───────┴──────────┘

Gantt Chart (Preemptive):
┌───┬───────────┬───────────────┬───────────────┐
│P1 │    P2     │      P3       │      P1       │
│0-1│   1-4     │     4-8       │     8-12      │
└───┴───────────┴───────────────┴───────────────┘
0   1           4               8               12

في الوقت 1: وصل P2 (priority=1) أعلى من P1 (priority=3) → Preempt
```

---

### 4.4 Round Robin

#### المفهوم
كل عملية تأخذ **شريحة زمنية** (Time Quantum) ثم تنتقل للعملية التالية في الطابور.

#### الخصائص
- ✅ **عادلة** - كل عملية تحصل على وقت
- ✅ Response Time جيد
- ✅ مناسبة للأنظمة التفاعلية
- ❌ Context Switching overhead
- ⚠️ اختيار Quantum مهم جداً

#### تأثير حجم Quantum
```
Quantum صغير جداً → Context Switching كثير → Overhead عالي
Quantum كبير جداً → يتحول إلى FCFS
Quantum مثالي → توازن بين Response Time و Overhead
```

#### الخوارزمية
```
1. أنشئ Ready Queue
2. current_time = 0
3. أضف العمليات التي وصلت
4. طالما يوجد عمليات:
   a. أخرج عملية من الطابور
   b. نفذها لمدة min(quantum, remaining_time)
   c. أضف العمليات الجديدة التي وصلت
   d. إذا لم تنتهي → أعدها للطابور
   e. إذا انتهت → احسب الأوقات
5. انتهى
```

#### Flowchart
```
┌─────────────────┐
│     البداية     │
└────────┬────────┘
         ▼
┌─────────────────┐
│ إنشاء Ready Queue│
│ Quantum = Q     │
└────────┬────────┘
         ▼
┌─────────────────┐
│ أضف العمليات   │
│ التي وصلت      │
└────────┬────────┘
         ▼
    ┌────┴────┐
    │ Queue   │
    │ فارغ؟   │
    └────┬────┘
     لا  │         نعم
         ▼          ▼
┌─────────────────┐  ┌───────────────┐
│ أخرج عملية P   │  │ هل يوجد      │
│ من الطابور     │  │ عمليات تنتظر؟│
└────────┬────────┘  └───────┬───────┘
         ▼               نعم │    لا
┌─────────────────┐         │     ▼
│ exec_time =     │    ┌────┘  ┌──────┐
│ min(Q, remaining)│    │      │النهاية│
└────────┬────────┘    │      └──────┘
         ▼             │
┌─────────────────┐    │
│ نفذ لمدة       │    │
│ exec_time      │    │
└────────┬────────┘    │
         ▼             │
┌─────────────────┐    │
│ أضف العمليات   │◄───┘
│ الجديدة        │
└────────┬────────┘
         ▼
    ┌────┴────┐
    │remaining│
    │   > 0?  │
    └────┬────┘
     نعم │         لا
         ▼          ▼
┌─────────────┐  ┌──────────────┐
│ أعد P      │  │ احسب:       │
│ للطابور    │  │ Completion   │
└─────────────┘  │ Waiting      │
                 │ Turnaround   │
                 └──────────────┘
```

#### مثال
```
العمليات:                    Quantum = 2
┌─────┬─────────┬───────┐
│ PID │ Arrival │ Burst │
├─────┼─────────┼───────┤
│ P1  │    0    │   5   │
│ P2  │    1    │   3   │
│ P3  │    2    │   6   │
└─────┴─────────┴───────┘

Gantt Chart:
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬───┐
│ P1  │ P2  │ P3  │ P1  │ P2  │ P3  │ P1  │P3 │
│ 0-2 │ 2-4 │ 4-6 │ 6-8 │8-9  │9-11 │11-12│12-14│
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴───┘
0     2     4     6     8   9    11    12    14

تتبع Remaining Time:
الوقت 0: P1(5)
الوقت 2: P1(3), P2(3), P3(6)  → نفذ P1, أصبح P1(3)
الوقت 4: P2(3), P3(6), P1(3)  → نفذ P2, أصبح P2(1)
الوقت 6: P3(6), P1(3), P2(1)  → نفذ P3, أصبح P3(4)
...وهكذا
```

---

## 5. مقارنة الخوارزميات

### 5.1 جدول المقارنة الشامل

| الخاصية | FCFS | SJF (NP) | SRTF | Priority (NP) | Priority (P) | Round Robin |
|---------|------|----------|------|---------------|--------------|-------------|
| **التعقيد** | O(n log n) | O(n²) | O(n²) | O(n²) | O(n²) | O(n) |
| **استباقية** | ❌ | ❌ | ✅ | ❌ | ✅ | ✅ |
| **Starvation** | ❌ | ✅ | ✅ | ✅ | ✅ | ❌ |
| **Convoy Effect** | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| **Context Switch** | قليل | قليل | كثير | قليل | كثير | كثير |
| **Avg WT** | عالي | أمثل | أمثل | متوسط | متوسط | متوسط |
| **Response Time** | ضعيف | متوسط | جيد | متوسط | جيد | ممتاز |
| **التنفيذ** | سهل جداً | سهل | متوسط | سهل | متوسط | سهل |
| **الاستخدام** | Batch | Batch | Interactive | Real-time | Real-time | Time-sharing |

### 5.2 متى تستخدم كل خوارزمية؟

```
┌─────────────────────────────────────────────────────────────────┐
│                  دليل اختيار الخوارزمية                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  هل النظام تفاعلي (Interactive)؟                               │
│       │                                                         │
│       ├── نعم ──► Round Robin (أفضل Response Time)             │
│       │                                                         │
│       └── لا ──► هل تعرف Burst Time مسبقاً؟                    │
│                    │                                            │
│                    ├── نعم ──► SJF/SRTF (أفضل Waiting Time)    │
│                    │                                            │
│                    └── لا ──► هل يوجد أولويات مختلفة؟          │
│                                  │                              │
│                                  ├── نعم ──► Priority          │
│                                  │                              │
│                                  └── لا ──► FCFS (بسيطة)       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 مقارنة بصرية

```
Average Waiting Time (أقل = أفضل):
SRTF      ████░░░░░░ (الأفضل)
SJF       █████░░░░░
RR        ██████░░░░
Priority  ███████░░░
FCFS      █████████░ (الأسوأ)

Response Time (أقل = أفضل):
RR        ██░░░░░░░░ (الأفضل)
SRTF      ████░░░░░░
Priority-P████░░░░░░
SJF       ██████░░░░
FCFS      █████████░ (الأسوأ)

Throughput (أعلى = أفضل):
SRTF      █████████░ (الأفضل)
SJF       █████████░
Priority  ████████░░
RR        ███████░░░
FCFS      ██████░░░░
```

---

## 6. المخططات البيانية

### 6.1 UML Class Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           types.cpp                                      │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐   ┌─────────────────────┐                      │
│  │      Process        │   │   ExecutionRecord   │                      │
│  ├─────────────────────┤   ├─────────────────────┤                      │
│  │ - id: int           │   │ - process_id: int   │                      │
│  │ - arrival_time: int │   │ - start_time: int   │                      │
│  │ - burst_time: int   │   │ - end_time: int     │                      │
│  │ - priority: int     │   └─────────────────────┘                      │
│  │ - remaining_time: int│                                               │
│  │ - waiting_time: int │   ┌─────────────────────┐                      │
│  │ - turnaround_time: int│ │  SchedulingResult   │                      │
│  │ - completion_time: int│ ├─────────────────────┤                      │
│  │ - start_time: int   │   │ - algorithm_name    │                      │
│  │ - is_completed: bool│   │ - processes[]       │                      │
│  ├─────────────────────┤   │ - process_count     │                      │
│  │ + create_process()  │   │ - timeline[]        │                      │
│  │ + reset_process()   │   │ - timeline_length   │                      │
│  └─────────────────────┘   │ - avg_waiting_time  │                      │
│                            │ - avg_turnaround    │                      │
│                            │ - cpu_utilization   │                      │
│                            └─────────────────────┘                      │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                        Data Structures                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐              │
│  │    Queue     │    │PriorityQueue │    │  LinkedList  │              │
│  ├──────────────┤    ├──────────────┤    ├──────────────┤              │
│  │- front: Node*│    │- heap: []    │    │- head: Node* │              │
│  │- rear: Node* │    │- size: int   │    │- tail: Node* │              │
│  │- size: int   │    │- capacity    │    │- size: int   │              │
│  ├──────────────┤    │- compare()   │    ├──────────────┤              │
│  │+ create()    │    ├──────────────┤    │+ insert_front│              │
│  │+ enqueue()   │    │+ create()    │    │+ insert_back │              │
│  │+ dequeue()   │    │+ insert()    │    │+ remove_front│              │
│  │+ peek()      │    │+ extract_min │    │+ remove_back │              │
│  │+ destroy()   │    │+ heapify_up  │    │+ find_min    │              │
│  └──────────────┘    │+ heapify_down│    └──────────────┘              │
│                      └──────────────┘                                   │
│  ┌──────────────┐                                                       │
│  │    Stack     │                                                       │
│  ├──────────────┤                                                       │
│  │- top: Node*  │                                                       │
│  │- size: int   │                                                       │
│  ├──────────────┤                                                       │
│  │+ push()      │                                                       │
│  │+ pop()       │                                                       │
│  │+ peek()      │                                                       │
│  └──────────────┘                                                       │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                          Algorithms                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │                      algorithms.cpp                             │     │
│  │ ┌─────────────────────────────────────────────────────────────┐│     │
│  │ │ + fcfs(processes[], count) → SchedulingResult               ││     │
│  │ │ + sjf_non_preemptive(processes[], count) → SchedulingResult ││     │
│  │ │ + sjf_preemptive(processes[], count) → SchedulingResult     ││     │
│  │ │ + priority_non_preemptive(processes[], count) → Result      ││     │
│  │ │ + priority_preemptive(processes[], count) → Result          ││     │
│  │ │ + round_robin(processes[], count, quantum) → Result         ││     │
│  │ │ + calculate_statistics(result) → void                       ││     │
│  │ └─────────────────────────────────────────────────────────────┘│     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 Sequence Diagram - تنفيذ خوارزمية

```
┌──────┐    ┌─────────┐    ┌──────────┐    ┌──────────┐
│ User │    │  Main   │    │   API    │    │Algorithm │
└──┬───┘    └────┬────┘    └────┬─────┘    └────┬─────┘
   │             │              │               │
   │ اختر خوارزمية│              │               │
   │────────────>│              │               │
   │             │              │               │
   │             │ api_run()    │               │
   │             │─────────────>│               │
   │             │              │               │
   │             │              │ fcfs() / sjf()│
   │             │              │──────────────>│
   │             │              │               │
   │             │              │    نتيجة      │
   │             │              │<──────────────│
   │             │              │               │
   │             │   نتيجة      │               │
   │             │<─────────────│               │
   │             │              │               │
   │   عرض النتائج│              │               │
   │<────────────│              │               │
   │             │              │               │
```

### 6.3 State Diagram - حالات العملية

```
                    ┌─────────────────────────────────────┐
                    │                                     │
                    ▼                                     │
┌───────┐      ┌─────────┐      ┌─────────┐      ┌───────┴───┐
│  New  │─────>│  Ready  │─────>│ Running │─────>│ Completed │
└───────┘      └────┬────┘      └────┬────┘      └───────────┘
   │               ▲ │              │ ▲
   │               │ │  Preempt    │ │
   │               │ └─────────────┘ │
   │               │                 │
   │               │   I/O Wait      │
   │               │  ┌─────────┐    │
   │               └──│ Waiting │────┘
   │                  └─────────┘
   │
وصول العملية
(Arrival)
```

### 6.4 Activity Diagram - النظام العام

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ┌─────────┐                                                   │
│  │ البداية │                                                   │
│  └────┬────┘                                                   │
│       ▼                                                        │
│  ┌─────────────────┐                                           │
│  │ عرض القائمة     │                                           │
│  └────────┬────────┘                                           │
│           ▼                                                    │
│  ┌────────┴────────┐                                           │
│  │ اختيار المستخدم │                                           │
│  └────────┬────────┘                                           │
│       ┌───┴───┬───────────┬───────────┬───────────┐           │
│       ▼       ▼           ▼           ▼           ▼           │
│  ┌────────┐ ┌──────┐ ┌─────────┐ ┌─────────┐ ┌────────┐      │
│  │إدخال   │ │تحميل │ │تشغيل   │ │تشغيل   │ │خروج   │      │
│  │يدوي    │ │ملف   │ │خوارزمية│ │الكل    │ │        │      │
│  └───┬────┘ └──┬───┘ └────┬────┘ └────┬────┘ └───┬────┘      │
│      │         │          │           │          │            │
│      ▼         ▼          │           │          ▼            │
│  ┌───────────────┐        │           │     ┌─────────┐      │
│  │ إضافة عمليات │        │           │     │ النهاية │      │
│  └───────┬───────┘        │           │     └─────────┘      │
│          │                │           │                       │
│          └────────────────┼───────────┘                       │
│                           ▼                                   │
│                  ┌─────────────────┐                          │
│                  │ تنفيذ الخوارزمية│                          │
│                  └────────┬────────┘                          │
│                           ▼                                   │
│                  ┌─────────────────┐                          │
│                  │ حساب الإحصائيات│                          │
│                  └────────┬────────┘                          │
│                           ▼                                   │
│                  ┌─────────────────┐                          │
│                  │ عرض Gantt Chart│                          │
│                  └────────┬────────┘                          │
│                           ▼                                   │
│                  ┌─────────────────┐                          │
│                  │ عرض النتائج    │                          │
│                  └────────┬────────┘                          │
│                           │                                   │
│                           └──────────────────► (العودة للقائمة)│
│                                                                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. دليل الاستخدام

### 7.1 البناء والتشغيل

#### البناء بـ CMake
```bash
# إنشاء مجلد البناء
mkdir build
cd build

# توليد ملفات البناء
cmake ..

# البناء
cmake --build .

# التشغيل
./CPUScheduling
```

#### البناء المباشر بـ g++
```bash
g++ -std=c++17 -o CPUScheduling main.cpp
./CPUScheduling
```

### 7.2 القائمة الرئيسية

```
=== CPU Scheduling Simulator ===
1. FCFS (First Come First Serve)
2. SJF Non-Preemptive
3. SJF Preemptive (SRTF)
4. Priority Non-Preemptive
5. Priority Preemptive
6. Round Robin
7. تشغيل جميع الخوارزميات
8. تحميل من ملف
9. إدخال يدوي
0. خروج
```

### 7.3 صيغة ملف الإدخال

```csv
# ملف بيانات العمليات
# PID, Arrival Time, Burst Time, Priority
1, 0, 5, 2
2, 1, 3, 1
3, 2, 8, 3
4, 3, 6, 4
```

### 7.4 تشغيل الواجهة الرسومية

```bash
# تثبيت المتطلبات
pip install flet

# تشغيل الواجهة
python gui/scheduler_gui.py

# فتح في المتصفح
http://localhost:8551
```

---

## 8. المراجع

### 8.1 مصادر علمية

1. **Operating System Concepts** - Silberschatz, Galvin, Gagne
   - الفصل 5: CPU Scheduling

2. **Modern Operating Systems** - Andrew S. Tanenbaum
   - الفصل 2: Processes and Threads

3. **Operating Systems: Three Easy Pieces** - Remzi & Andrea Arpaci-Dusseau
   - متاح مجاناً: https://pages.cs.wisc.edu/~remzi/OSTEP/

### 8.2 روابط مفيدة

- [GeeksforGeeks - CPU Scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/)
- [Wikipedia - Scheduling](https://en.wikipedia.org/wiki/Scheduling_(computing))

### 8.3 أدوات التطوير

- **IDE**: CLion / VS Code
- **Compiler**: GCC / MinGW
- **Build System**: CMake
- **GUI Framework**: Flet (Python)
- **Version Control**: Git

---

## 📝 الملاحظات الختامية

هذا المشروع هو مشروع **تعليمي** يهدف إلى فهم:
- كيفية عمل خوارزميات جدولة المعالج
- بناء هياكل البيانات من الصفر
- الفرق بين الخوارزميات المختلفة

**تم البناء بدون استخدام أي مكتبات جاهزة لهياكل البيانات أو الخوارزميات.**

---

<div align="center">

**تم إعداد هذا التوثيق لمشروع محاكي جدولة المعالج**

**© 2026**

</div>
